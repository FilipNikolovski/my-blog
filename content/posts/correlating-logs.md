---
title: "Correlating Logs"
date: 2020-08-21T19:11:28+02:00
description: Using correlation id to tie in multiple logs generated by your microservices.
draft: true 
categories:
  - Programming
tags:
  - Logs
  - Go
  - Microservices
---

When something goes wrong in your system, logs are crucial to find out exactly what's happened. Usually this involves following the logs as a 
trail of breadcrumbs that lead to the root cause of the failure. If your application is generating a lot of logs, it can become strenuous to 
tie everything together that reveals the failing scenario.

This can become especially challenging in a distributed system, where one HTTP request to your API can pass through dozens of different services, 
each outputting logs that have no context of the flow of the request.

In this post we'll firstly define what a structured log is and then explore a solution on how to tie in the mutual logs in a **Go application**, using context, 
structured logging and correlation ids. Although the following example will be entirely in Go, the principle should be the same for apps written in different programming languages.

## Structured logs 

Before we talk about correlating logs, we need a way to make sense of this data that we are writing. Logs are typically just an unstructured text which 
makes it hard to extract useful information from them by another machine. In order to be able to query or filter them by something, the logs need to 
be written in a format that can be easily parsed and indexed. 

Here is an example of an unstructured log record: 

```go
INFO: 2009/11/10 23:00:00 192.168.0.2 Hello World! 
```

Versus a structured one:

```json
{"time": 1562212768, "host": "192.168.0.2", "level": "INFO", "message": "Hello World!"}
```

The structured log essentially contains the same information as the unstructured one, but the key difference is that the message is in a format that
another machine can understand (it can be JSON, XML, whatever) and the fields can be identified, indexed and other programs such as logging systems 
can analyze them so that later on we can use these fields in order to search and filter results.

Let's see this in action in a **Go app**. There are plenty of libraries for structured logging in Go, some of the more popular ones are 
[Zerolog](https://github.com/rs/zerolog), [Zap](https://github.com/uber-go/zap), and [Logrus](https://github.com/sirupsen/logrus).

We'll use Zerolog as an example. From the package description it says that it provides "a fast and simple logger dedicated to JSON output". It has
features such as contextual fields, log levels and passing the logger by context, which is exactly what we're looking for.

Here's how we can create the log from the example above:

```go
package main

import (
    "github.com/rs/zerolog"
    "github.com/rs/zerolog/log"
)

func main() {
    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

    log.Info().
        Str("host", "192.168.0.2").
        Msg("Hello World!") 
}
// Output: {"time": 1562212768, "host": "192.168.0.2", "level": "info", "message": "Hello World!"}
```

In a typical web app you would have your controllers, middleware, services and domain logic code that will be invoked on each user request. As we
go down the stack, we can have multiple logs that are being written for the same action, each log telling only a part of the story. Then, when something bad happens
and we want to investigate, we would need to bring the pieces together like a puzzle, in order to make sense of the situation.

The problem gets more convoluted in a distributed systems scenario, where separate services are part of this one big user action, each outputting their own logs that are
difficult to follow and make sense of, when it comes to understanding the bigger picture. Finding the service that is the culprit will be like playing detective.

To avoid having to become Sherlock as you intuitively search through the big pile of messages, you could simply connect them by having an additional field in 
the structure of the log - a **correlation id**. This id can be generated on each request, somewhere on top of the call chain and propagated down to be used as part of each 
logged message.

We can illustrate this concept in a Go app by creating and using a **HTTP middleware**, the **context object**, and our trusty old logger. The basic principle of a middleware is that it's a way of organizing a shared
functionality that we want to run on each HTTP request. This code usually sits between the router and the application controllers.

**Note:** I won't cover the whole story on how to create and use middlewares since there are [great posts](https://www.alexedwards.net/blog/making-and-using-middleware) 
about it that go into [detail](https://drstearns.github.io/tutorials/gomiddleware/), as well as some great libraries (such as [Negroni](https://github.com/urfave/negroni)),
check them out for more info.

Anyway, the gist of it is that a middleware is essentially a function that implements the [http.Handler](https://pkg.go.dev/net/http?tab=doc#Handler) interface 
and it takes a handler function as a parameter which is the `next` handler that should be invoked, after the middleware code is done.

```go
func someMiddleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // Middleware logic.. 
    next.ServeHTTP(w, r)
  })
}
```

This allows us to chain multiple handlers together, so in our scenario we'll end up having a handler that generates IDs and passes them down that wraps each application handler.

The flow of control will look something like this:

```
Router --> Generate correlation ID Middleware --> App handler
```

## An example

We can illustrate this in code with a simple example, where we will:

  - Fetch the correlation id from a header if it's present (something like **X-Correlation-Id**)
  - In case the header is not present, we'll generate a random id and add it to the response header. This will
    make our debugging easier since we'll receive the id in our response.
  - Pass it down to our logger instance
  - Call the next handler

```go
package main

import (
  "os"
  "net/http"
  
  
  "github.com/rs/zerolog"
  "github.com/rs/zerolog/hlog"
)

func correlationIDMiddleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    
    next.ServeHTTP(w, r)
  })
}

func testHandler(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("OK"))
}

func main() {
  log := zerolog.New(os.Stdout).With().
    Timestamp().
    Logger()
    
  mux := http.NewServeMux()

  // NewHandler returns a middleware with the log object set in the request context
  initLogMiddleware := hlog.NewHandler(log)
  
  mux.Handle("/", 
    initLogMiddleware(
      correlationIDMiddleware(
        http.HandlerFunc(testHandler),
      ),
    ),
  )

  log.Println("Listening on :8080...")
  err := http.ListenAndServe(":8080", mux)
  log.Fatal(err)
} 
```
